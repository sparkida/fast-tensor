/**
 * Builds the typescript definitions for Wasm output Module
 * by parsing the AST of the C++ Bindings
 * and prints the names to stdout for use in Makefile
 */
import fs from 'fs';
import Parser from 'tree-sitter';
import Cpp from 'tree-sitter-cpp';

// Configure the parser with the C++ grammar
const parser = new Parser();
parser.setLanguage(Cpp);

// Utility to map C++ types to TypeScript types
const cppToTsTypeMap = {
  'int': 'number',
  'size_t': 'number',
  'uint32_t': 'number',
  'float': 'number',
  'double': 'number',
  'Real': 'number',
  'bool': 'boolean',
  'char': 'string',
  'std::string': 'string',
  'void': 'void',
};

const header = `/** generated by build-exports.mjs */
export interface WasmModule {
    HEAP8: Int8Array;
    HEAP16: Int16Array;
    HEAP32: Int32Array;
    HEAPU8: Uint8Array;
    HEAPU16: Uint16Array;
    HEAPU32: Uint32Array;
    HEAPF32: Float32Array;
    HEAPF64: Float64Array;
    default: (...args: unknown[]) => Promise<WasmModule>;
`;
const footer = '\n}\n';

// Function to convert C++ types to TypeScript types
function mapCppTypeToTs(cppType) {
  return cppToTsTypeMap[cppType] || 'any';
}

// Read and parse the Bindings.cpp file
const cppCode = fs.readFileSync('./src/cpp/Bindings.cpp', 'utf8');
const tree = parser.parse(cppCode);

function findFuncAndParams(node) {
  const nextDeclarator = node.childForFieldName('declarator');
  if (nextDeclarator.type === 'function_declarator') {
    return nextDeclarator.children;
  }
  return findFuncAndParams(nextDeclarator);
}

// Function to extract function signatures from the AST
function extractFunctionSignatures(functionNodes) {
  const exportNames = [
    '_malloc',
    '_free',
  ];
  const functions = [
    '    _malloc: (size: number) => number;',
    '    _free: (ptr: number) => void;',
  ];
  for (const funcNode of functionNodes) {
    // Get return type
    let returnType = funcNode.childForFieldName('type').text;
    returnType = mapCppTypeToTs(returnType);
    if (/^\w+\s*\*/.test(funcNode.text)) {
      // is a pointer, always returns number
      returnType = 'number';
    }
    let [funcNameNode, paramListNode] = findFuncAndParams(funcNode);

    const funcName = `_${funcNameNode.text}`;
    exportNames.push(funcName);
    const parameters = [];
    if (paramListNode) {
      // TODO handle optional and default
      paramListNode.children.forEach((paramNode) => {
        // could be optional_parameter_declaration
        if (!paramNode.type.includes('parameter_declaration')) {
          return;
        }
        let paramType = paramNode.childForFieldName('type').text;
        let paramName = paramNode.childForFieldName('declarator').text;//.replace(/[^a-zA-Z]/g, '');
        paramType = mapCppTypeToTs(paramType);
        if (/^(\*|&)/.test(paramName)) {
          // pointer or reference - always a number
          paramType = 'number';
          paramName = paramName.replace(/[^a-zA-Z_]/g, '') + 'Ptr';
        }
        // convert snake to camel case
        paramName = paramName.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
        parameters.push(`${paramName}: ${paramType}`);
      });
    }
    // Generate the TypeScript function signature
    const tsSignature = `    ${funcName}: (${parameters.join(', ')}) => ${returnType};`;
    functions.push(tsSignature);
  }

  return [functions, exportNames];
}

const linkage = tree.rootNode.children.find(n => n.type === 'linkage_specification');
const declarations = linkage.children.find(n => n.type === 'declaration_list');
const functionNodes = declarations.children.filter(n => n.type === 'function_definition')

// Extract and output the TypeScript signatures
const [signatures, exportNames] = extractFunctionSignatures(functionNodes);
fs.writeFileSync('./src/ts/types/WasmModule.d.ts', header + signatures.join('\n') + footer);
//console.log('TypeScript signatures generated in ./src/ts/WasmModule.d.ts');
process.stdout.write(JSON.stringify(exportNames).replaceAll('"', "'"));
